using System;
using Serilog.Events;

namespace Serilog.Utf8.Commons;

/// <summary>
/// An abstract base class for visitors that walk data in the
/// <see cref="LogEventPropertyValue"/> format. Subclasses, by
/// overriding appropriate methods, may search for, transform,
/// or print the value structures being visited.
/// </summary>
/// <remarks>
/// Stateless, designed to accommodate allocation-free visiting of multiple
/// values by the same visitor instance.
/// </remarks>  
/// <typeparam name="TResult">The type of the result generated by visiting
/// a node.</typeparam>
abstract class SpanLogEventPropertyValueVisitor<TResult>
{
  /// <summary>
  /// Visit the root node type. This method delegates to
  /// a concrete Visit*Value() method appropriate for the value.
  /// </summary>
  /// <param name="state">Operation state.</param>
  /// <param name="value">The value to visit.</param>
  /// <returns>The result of visiting <paramref name="value"/>.</returns>
  /// <exception cref="ArgumentNullException">When <paramref name="value"/> is <code>null</code></exception>
  protected virtual TResult Visit(ref Utf8Writer state, LogEventPropertyValue value)
  {
    ArgumentNullException.ThrowIfNull(value);

    if (value is ScalarValue sv)
      return VisitScalarValue(ref state, sv);

    if (value is SequenceValue seqv)
      return VisitSequenceValue(ref state, seqv);

    if (value is StructureValue strv)
      return VisitStructureValue(ref state, strv);

    if (value is DictionaryValue dictv)
      return VisitDictionaryValue(ref state, dictv);

    return VisitUnsupportedValue(ref state, value);
  }

  /// <summary>
  /// Visit a <see cref="ScalarValue"/> value.
  /// </summary>
  /// <param name="state">Operation state.</param>
  /// <param name="scalar">The value to visit.</param>
  /// <returns>The result of visiting <paramref name="scalar"/>.</returns>
  protected abstract TResult VisitScalarValue(ref Utf8Writer state, ScalarValue scalar);

  /// <summary>
  /// Visit a <see cref="SequenceValue"/> value.
  /// </summary>
  /// <param name="state">Operation state.</param>
  /// <param name="sequence">The value to visit.</param>
  /// <returns>The result of visiting <paramref name="sequence"/>.</returns>
  protected abstract TResult VisitSequenceValue(ref Utf8Writer state, SequenceValue sequence);

  /// <summary>
  /// Visit a <see cref="StructureValue"/> value.
  /// </summary>
  /// <param name="state">Operation state.</param>
  /// <param name="structure">The value to visit.</param>
  /// <returns>The result of visiting <paramref name="structure"/>.</returns>
  protected abstract TResult VisitStructureValue(ref Utf8Writer state, StructureValue structure);

  /// <summary>
  /// Visit a <see cref="DictionaryValue"/> value.
  /// </summary>
  /// <param name="state">Operation state.</param>
  /// <param name="dictionary">The value to visit.</param>
  /// <returns>The result of visiting <paramref name="dictionary"/>.</returns>
  protected abstract TResult VisitDictionaryValue(ref Utf8Writer state, DictionaryValue dictionary);

  /// <summary>
  /// Visit a value of an unsupported type. Always throws <see cref="NotSupportedException"/>, when is not overridden.
  /// </summary>
  /// <param name="state">Operation state.</param>
  /// <param name="value">The value to visit.</param>
  /// <returns>The result of visiting <paramref name="value"/>.</returns>
  /// <exception cref="ArgumentNullException">When <paramref name="value"/> is <code>null</code></exception>
  /// <exception cref="NotSupportedException">Always</exception>
  // ReSharper disable once UnusedParameter.Global
  protected virtual TResult VisitUnsupportedValue(ref Utf8Writer state, LogEventPropertyValue value)
  {
    ArgumentNullException.ThrowIfNull(value);
    throw new NotSupportedException($"The value {value} is not of a type supported by this visitor.");
  }
}